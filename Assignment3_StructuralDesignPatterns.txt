
Assignment 3 — Structural Design Patterns (Java Console Version)
===============================================================

SET A
-----

Q1. Decorator Pattern – Convert Uppercase to Lowercase
------------------------------------------------------
Steps to Solve:
1. Create an interface Text with method read().
2. Implement PlainText that returns text.
3. Create LowerCaseDecorator that wraps another Text object.

Code:
----- Text.java -----
public interface Text {
    String read();
}

----- PlainText.java -----
public class PlainText implements Text {
    private String content;
    public PlainText(String content) { this.content = content; }
    public String read() { return content; }
}

----- LowerCaseDecorator.java -----
public class LowerCaseDecorator implements Text {
    private Text text;
    public LowerCaseDecorator(Text text) { this.text = text; }
    public String read() { return text.read().toLowerCase(); }
}

----- DecoratorDemo.java -----
public class DecoratorDemo {
    public static void main(String[] args) {
        Text t = new PlainText("HELLO WORLD");
        Text lower = new LowerCaseDecorator(t);
        System.out.println("Original: " + t.read());
        System.out.println("Lowercase: " + lower.read());
    }
}

------------------------------------------------------

Q2. Adapter Pattern – Enumeration to Iterator
---------------------------------------------
Steps to Solve:
1. Create an adapter class implementing Iterator.
2. Pass an Enumeration object to it.
3. Use it as an Iterator.

Code:
import java.util.*;

public class EnumerationIteratorAdapter implements Iterator<Object> {
    Enumeration<?> enumeration;
    public EnumerationIteratorAdapter(Enumeration<?> enumeration) {
        this.enumeration = enumeration;
    }

    public boolean hasNext() { return enumeration.hasMoreElements(); }
    public Object next() { return enumeration.nextElement(); }
}

public class AdapterDemo {
    public static void main(String[] args) {
        Vector<String> v = new Vector<>();
        v.add("Apple");
        v.add("Banana");
        v.add("Cherry");
        Enumeration<String> e = v.elements();
        Iterator<Object> iterator = new EnumerationIteratorAdapter(e);
        while (iterator.hasNext()) {
            System.out.println(iterator.next());
        }
    }
}

------------------------------------------------------

Q3. Bridge Pattern – Vehicle Production
---------------------------------------
Steps to Solve:
1. Create Workshop interface with method work().
2. Implement Produce and Assemble.
3. Create abstract Vehicle with manufacture() calling both workshops.
4. Create Car and Bike extending Vehicle.

Code:
----- Workshop.java -----
public interface Workshop {
    void work();
}

----- Produce.java -----
public class Produce implements Workshop {
    public void work() { System.out.println("Producing vehicle parts"); }
}

----- Assemble.java -----
public class Assemble implements Workshop {
    public void work() { System.out.println("Assembling the vehicle"); }
}

----- Vehicle.java -----
public abstract class Vehicle {
    protected Workshop w1;
    protected Workshop w2;
    protected Vehicle(Workshop w1, Workshop w2) {
        this.w1 = w1;
        this.w2 = w2;
    }
    abstract void manufacture();
}

----- Car.java -----
public class Car extends Vehicle {
    public Car(Workshop w1, Workshop w2) { super(w1, w2); }
    public void manufacture() {
        System.out.print("Car ");
        w1.work();
        w2.work();
    }
}

----- Bike.java -----
public class Bike extends Vehicle {
    public Bike(Workshop w1, Workshop w2) { super(w1, w2); }
    public void manufacture() {
        System.out.print("Bike ");
        w1.work();
        w2.work();
    }
}

----- BridgeDemo.java -----
public class BridgeDemo {
    public static void main(String[] args) {
        Vehicle car = new Car(new Produce(), new Assemble());
        car.manufacture();
        Vehicle bike = new Bike(new Produce(), new Assemble());
        bike.manufacture();
    }
}

------------------------------------------------------

SET B
-----

Q1. Adapter Pattern – Heart Model to Beat Model
-----------------------------------------------
Code:
interface HeartModel {
    int getHeartRate();
}

interface BeatModel {
    void beat();
}

class HeartModelImpl implements HeartModel {
    public int getHeartRate() { return 72; }
}

class HeartToBeatAdapter implements BeatModel {
    private HeartModel heart;
    public HeartToBeatAdapter(HeartModel heart) { this.heart = heart; }
    public void beat() {
        System.out.println("Heart beating at " + heart.getHeartRate() + " bpm");
    }
}

public class HeartAdapterDemo {
    public static void main(String[] args) {
        HeartModel heart = new HeartModelImpl();
        BeatModel beatModel = new HeartToBeatAdapter(heart);
        beatModel.beat();
    }
}

------------------------------------------------------

Q2. Proxy Pattern – Image Loading
---------------------------------
Code:
interface Image {
    void display();
}

class RealImage implements Image {
    private String filename;
    public RealImage(String filename) {
        this.filename = filename;
        loadFromDisk();
    }
    private void loadFromDisk() {
        System.out.println("Loading " + filename);
    }
    public void display() {
        System.out.println("Displaying " + filename);
    }
}

class ProxyImage implements Image {
    private RealImage realImage;
    private String filename;
    public ProxyImage(String filename) { this.filename = filename; }
    public void display() {
        if (realImage == null) realImage = new RealImage(filename);
        realImage.display();
    }
}

public class ProxyDemo {
    public static void main(String[] args) {
        Image image = new ProxyImage("photo.png");
        image.display();
        image.display();
    }
}

------------------------------------------------------

Q3. Decorator Pattern – Pizza Toppings
-------------------------------------
Code:
interface Pizza {
    String getDescription();
    double getCost();
}

class BasicPizza implements Pizza {
    public String getDescription() { return "Plain Pizza"; }
    public double getCost() { return 100; }
}

class CheeseDecorator implements Pizza {
    private Pizza pizza;
    public CheeseDecorator(Pizza pizza) { this.pizza = pizza; }
    public String getDescription() { return pizza.getDescription() + ", Cheese"; }
    public double getCost() { return pizza.getCost() + 20; }
}

class OliveDecorator implements Pizza {
    private Pizza pizza;
    public OliveDecorator(Pizza pizza) { this.pizza = pizza; }
    public String getDescription() { return pizza.getDescription() + ", Olives"; }
    public double getCost() { return pizza.getCost() + 15; }
}

public class PizzaDecoratorDemo {
    public static void main(String[] args) {
        Pizza pizza = new BasicPizza();
        pizza = new CheeseDecorator(pizza);
        pizza = new OliveDecorator(pizza);
        System.out.println(pizza.getDescription() + " => Rs." + pizza.getCost());
    }
}

------------------------------------------------------

SET C
-----

Q1. Composite Pattern – Employee Hierarchy
------------------------------------------
Code:
import java.util.*;

class Employee {
    private String name;
    private String role;
    private List<Employee> subordinates;

    public Employee(String name, String role) {
        this.name = name;
        this.role = role;
        subordinates = new ArrayList<>();
    }

    public void add(Employee e) { subordinates.add(e); }
    public void remove(Employee e) { subordinates.remove(e); }
    public List<Employee> getSubordinates() { return subordinates; }

    public void showDetails() {
        System.out.println(role + ": " + name);
        for (Employee e : subordinates) {
            e.showDetails();
        }
    }
}

public class CompositeDemo {
    public static void main(String[] args) {
        Employee ceo = new Employee("Raj", "CEO");
        Employee headSales = new Employee("Amit", "Head Sales");
        Employee salesExec1 = new Employee("John", "Sales Executive");
        Employee salesExec2 = new Employee("Doe", "Sales Executive");

        ceo.add(headSales);
        headSales.add(salesExec1);
        headSales.add(salesExec2);

        ceo.showDetails();
    }
}

------------------------------------------------------

HOW TO RUN THE FILES
--------------------
1. Save each class in a .java file with the same name as its public class.
2. Open a terminal in the folder containing the files.
3. Compile all files:
   javac *.java
4. Run the main demo class, e.g.:
   java DecoratorDemo
   java BridgeDemo
   java ProxyDemo
5. Observe console output.

===============================================================
End of Assignment 3 — Structural Design Patterns
===============================================================
